{"ast":null,"code":"var t = Object.freeze({\n  get start() {\n    return Ct;\n  },\n\n  get ensureJQuerySupport() {\n    return lt;\n  },\n\n  get setBootstrapMaxTime() {\n    return D;\n  },\n\n  get setMountMaxTime() {\n    return U;\n  },\n\n  get setUnmountMaxTime() {\n    return C;\n  },\n\n  get setUnloadMaxTime() {\n    return I;\n  },\n\n  get registerApplication() {\n    return Pt;\n  },\n\n  get getMountedApps() {\n    return wt;\n  },\n\n  get getAppStatus() {\n    return bt;\n  },\n\n  get unloadApplication() {\n    return Nt;\n  },\n\n  get checkActivityFunctions() {\n    return Ot;\n  },\n\n  get getAppNames() {\n    return yt;\n  },\n\n  get declareChildApplication() {\n    return Et;\n  },\n\n  get unloadChildApplication() {\n    return At;\n  },\n\n  get navigateToUrl() {\n    return nt;\n  },\n\n  get triggerAppChange() {\n    return _t;\n  },\n\n  get addErrorHandler() {\n    return c;\n  },\n\n  get removeErrorHandler() {\n    return s;\n  },\n\n  get mountRootParcel() {\n    return Q;\n  },\n\n  get NOT_LOADED() {\n    return l;\n  },\n\n  get LOADING_SOURCE_CODE() {\n    return p;\n  },\n\n  get NOT_BOOTSTRAPPED() {\n    return m;\n  },\n\n  get BOOTSTRAPPING() {\n    return d;\n  },\n\n  get NOT_MOUNTED() {\n    return h;\n  },\n\n  get MOUNTING() {\n    return v;\n  },\n\n  get UPDATING() {\n    return w;\n  },\n\n  get MOUNTED() {\n    return g;\n  },\n\n  get UNMOUNTING() {\n    return y;\n  },\n\n  get SKIP_BECAUSE_BROKEN() {\n    return E;\n  }\n\n}),\n    n = (\"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {}).CustomEvent;\nvar e = function () {\n  try {\n    var t = new n(\"cat\", {\n      detail: {\n        foo: \"bar\"\n      }\n    });\n    return \"cat\" === t.type && \"bar\" === t.detail.foo;\n  } catch (t) {}\n\n  return !1;\n}() ? n : \"undefined\" != typeof document && \"function\" == typeof document.createEvent ? function (t, n) {\n  var e = document.createEvent(\"CustomEvent\");\n  return n ? e.initCustomEvent(t, n.bubbles, n.cancelable, n.detail) : e.initCustomEvent(t, !1, !1, void 0), e;\n} : function (t, n) {\n  var e = document.createEventObject();\n  return e.type = t, n ? (e.bubbles = Boolean(n.bubbles), e.cancelable = Boolean(n.cancelable), e.detail = n.detail) : (e.bubbles = !1, e.cancelable = !1, e.detail = void 0), e;\n};\n\nfunction r(t) {\n  return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n    return typeof t;\n  } : function (t) {\n    return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  })(t);\n}\n\nfunction o(t, n, e) {\n  return n in t ? Object.defineProperty(t, n, {\n    value: e,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[n] = e, t;\n}\n\nfunction i(t) {\n  for (var n = 1; n < arguments.length; n++) {\n    var e = null != arguments[n] ? arguments[n] : {},\n        r = Object.keys(e);\n    \"function\" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(e).filter(function (t) {\n      return Object.getOwnPropertyDescriptor(e, t).enumerable;\n    }))), r.forEach(function (n) {\n      o(t, n, e[n]);\n    });\n  }\n\n  return t;\n}\n\nvar a = [];\n\nfunction u(t, n) {\n  var e = f(t, n);\n  a.length ? a.forEach(function (t) {\n    return t(e);\n  }) : setTimeout(function () {\n    throw e;\n  });\n}\n\nfunction c(t) {\n  if (\"function\" != typeof t) throw Error(\"a single-spa error handler must be a function\");\n  a.push(t);\n}\n\nfunction s(t) {\n  if (\"function\" != typeof t) throw Error(\"a single-spa error handler must be a function\");\n  var n = !1;\n  return a = a.filter(function (e) {\n    var r = e === t;\n    return n = n || r, !r;\n  }), n;\n}\n\nfunction f(t, n) {\n  var e,\n      r = n.unmountThisParcel ? \"Parcel\" : \"Application\",\n      o = \"\".concat(r, \" '\").concat(n.name, \"' died in status \").concat(n.status, \": \");\n\n  if (t instanceof Error) {\n    try {\n      t.message = o + t.message;\n    } catch (t) {}\n\n    e = t;\n  } else {\n    console.warn(\"While \".concat(n.status, \", '\").concat(n.name, \"' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.\"));\n\n    try {\n      e = Error(o + JSON.stringify(t));\n    } catch (n) {\n      e = t;\n    }\n  }\n\n  return e.appName = n.name, e.name = n.name, e;\n}\n\nvar l = \"NOT_LOADED\",\n    p = \"LOADING_SOURCE_CODE\",\n    m = \"NOT_BOOTSTRAPPED\",\n    d = \"BOOTSTRAPPING\",\n    h = \"NOT_MOUNTED\",\n    v = \"MOUNTING\",\n    g = \"MOUNTED\",\n    w = \"UPDATING\",\n    y = \"UNMOUNTING\",\n    b = \"UNLOADING\",\n    E = \"SKIP_BECAUSE_BROKEN\";\n\nfunction P(t) {\n  return t.status === g;\n}\n\nfunction O(t) {\n  return !P(t);\n}\n\nfunction T(t) {\n  return t.status !== l && t.status !== p;\n}\n\nfunction A(t) {\n  return !T(t);\n}\n\nfunction N(t) {\n  try {\n    return t.activeWhen(window.location);\n  } catch (n) {\n    u(n, t), t.status = E;\n  }\n}\n\nfunction S(t) {\n  try {\n    return !t.activeWhen(window.location);\n  } catch (n) {\n    u(n, t), t.status = E;\n  }\n}\n\nfunction j(t) {\n  return t !== E && (!t || t.status !== E);\n}\n\nfunction x(t) {\n  return t.name;\n}\n\nvar _ = {\n  bootstrap: {\n    millis: 4e3,\n    dieOnTimeout: !1\n  },\n  mount: {\n    millis: 3e3,\n    dieOnTimeout: !1\n  },\n  unmount: {\n    millis: 3e3,\n    dieOnTimeout: !1\n  },\n  unload: {\n    millis: 3e3,\n    dieOnTimeout: !1\n  }\n};\n\nfunction D(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  if (\"number\" != typeof t || t <= 0) throw Error(\"bootstrap max time must be a positive integer number of milliseconds\");\n  _.bootstrap = {\n    millis: t,\n    dieOnTimeout: n\n  };\n}\n\nfunction U(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  if (\"number\" != typeof t || t <= 0) throw Error(\"mount max time must be a positive integer number of milliseconds\");\n  _.mount = {\n    millis: t,\n    dieOnTimeout: n\n  };\n}\n\nfunction C(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  if (\"number\" != typeof t || t <= 0) throw Error(\"unmount max time must be a positive integer number of milliseconds\");\n  _.unmount = {\n    millis: t,\n    dieOnTimeout: n\n  };\n}\n\nfunction I(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  if (\"number\" != typeof t || t <= 0) throw Error(\"unload max time must be a positive integer number of milliseconds\");\n  _.unload = {\n    millis: t,\n    dieOnTimeout: n\n  };\n}\n\nfunction L(t, n, e) {\n  var r = 1e3;\n  return new Promise(function (o, i) {\n    var a = !1,\n        u = !1;\n\n    function c(t) {\n      if (!a) if (!0 === t) u = !0, e.dieOnTimeout ? i(\"\".concat(n, \" did not resolve or reject for \").concat(e.millis, \" milliseconds\")) : console.error(\"\".concat(n, \" did not resolve or reject for \").concat(e.millis, \" milliseconds -- we're no longer going to warn you about it.\"));else if (!u) {\n        var o = t,\n            s = o * r;\n        console.warn(\"\".concat(n, \" did not resolve or reject within \").concat(s, \" milliseconds\")), s + r < e.millis && setTimeout(function () {\n          return c(o + 1);\n        }, r);\n      }\n    }\n\n    t.then(function (t) {\n      a = !0, o(t);\n    }).catch(function (t) {\n      a = !0, i(t);\n    }), setTimeout(function () {\n      return c(1);\n    }, r), setTimeout(function () {\n      return c(!0);\n    }, e.millis);\n  });\n}\n\nfunction M() {\n  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n  return i({}, _, t);\n}\n\nfunction B(t, n) {\n  for (var e = 0; e < t.length; e++) {\n    if (n(t[e])) return t[e];\n  }\n\n  return null;\n}\n\nfunction G(t) {\n  return t && (\"function\" == typeof t || (n = t, Array.isArray(n) && !B(n, function (t) {\n    return \"function\" != typeof t;\n  })));\n  var n;\n}\n\nfunction R(t, n) {\n  return 0 === (t = Array.isArray(t) ? t : [t]).length && (t = [function () {\n    return Promise.resolve();\n  }]), function (e) {\n    return new Promise(function (r, o) {\n      !function i(a) {\n        var u = t[a](e);\n        k(u) ? u.then(function () {\n          a === t.length - 1 ? r() : i(a + 1);\n        }).catch(o) : o(\"\".concat(n, \" at index \").concat(a, \" did not return a promise\"));\n      }(0);\n    });\n  };\n}\n\nfunction k(t) {\n  return t && \"function\" == typeof t.then && \"function\" == typeof t.catch;\n}\n\nfunction q(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  return Promise.resolve().then(function () {\n    return t.status !== m ? t : (t.status = d, L(t.bootstrap(X(t)), \"Bootstrapping appOrParcel '\".concat(t.name, \"'\"), t.timeouts.bootstrap).then(function () {\n      return t.status = h, t;\n    }).catch(function (e) {\n      if (t.status = E, n) throw f(e, t);\n      return u(e, t), t;\n    }));\n  });\n}\n\nfunction W(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  return Promise.resolve().then(function () {\n    if (t.status !== g) return t;\n    t.status = y;\n    var e = Object.keys(t.parcels).map(function (n) {\n      return t.parcels[n].unmountThisParcel();\n    });\n    return Promise.all(e).then(r, function (e) {\n      return r().then(function () {\n        var r = Error(e.message);\n\n        if (n) {\n          var o = f(r, t);\n          throw t.status = E, o;\n        }\n\n        u(r, t), t.status = E;\n      });\n    }).then(function () {\n      return t;\n    });\n\n    function r() {\n      return L(t.unmount(X(t)), \"Unmounting application \".concat(t.name, \"'\"), t.timeouts.unmount).then(function () {\n        t.status = h;\n      }).catch(function (e) {\n        if (n) {\n          var r = f(e, t);\n          throw t.status = E, r;\n        }\n\n        u(e, t), t.status = E;\n      });\n    }\n  });\n}\n\nvar F = !1,\n    K = !1;\n\nfunction $(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n  return Promise.resolve().then(function () {\n    return t.status !== h ? t : (F || (window.dispatchEvent(new e(\"single-spa:before-first-mount\")), F = !0), L(t.mount(X(t)), \"Mounting application '\".concat(t.name, \"'\"), t.timeouts.mount).then(function () {\n      return t.status = g, K || (window.dispatchEvent(new e(\"single-spa:first-mount\")), K = !0), t;\n    }).catch(function (e) {\n      return t.status = g, W(t).then(r, r);\n\n      function r() {\n        if (n) {\n          var r = f(e, t);\n          throw t.status = E, r;\n        }\n\n        return u(e, t), t.status = E, t;\n      }\n    }));\n  });\n}\n\nvar H = 0,\n    J = {\n  parcels: {}\n};\n\nfunction Q() {\n  return V.apply(J, arguments);\n}\n\nfunction V(t, n) {\n  var e = this;\n  if (!t || \"object\" !== r(t) && \"function\" != typeof t) throw Error(\"Cannot mount parcel without a config object or config loading function\");\n  if (t.name && \"string\" != typeof t.name) throw Error(\"Parcel name must be a string, if provided\");\n  if (\"object\" !== r(n)) throw Error(\"Parcel \".concat(name, \" has invalid customProps -- must be an object\"));\n  if (!n.domElement) throw Error(\"Parcel \".concat(name, \" cannot be mounted without a domElement provided as a prop\"));\n  var o,\n      i = H++,\n      a = \"function\" == typeof t,\n      u = a ? t : function () {\n    return Promise.resolve(t);\n  },\n      c = {\n    id: i,\n    parcels: {},\n    status: a ? p : m,\n    customProps: n,\n    parentName: e.name,\n    unmountThisParcel: function unmountThisParcel() {\n      if (c.status !== g) throw Error(\"Cannot unmount parcel '\".concat(name, \"' -- it is in a \").concat(c.status, \" status\"));\n      return W(c, !0).then(function (t) {\n        return c.parentName && delete e.parcels[c.id], t;\n      }).then(function (t) {\n        return l(t), t;\n      }).catch(function (t) {\n        throw c.status = E, d(t), t;\n      });\n    }\n  };\n  e.parcels[i] = c;\n  var s = u();\n  if (!s || \"function\" != typeof s.then) throw Error(\"When mounting a parcel, the config loading function must return a promise that resolves with the parcel config\");\n  var l,\n      d,\n      v = (s = s.then(function (t) {\n    if (!t) throw Error(\"When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config\");\n    var n = t.name || \"parcel-\".concat(i);\n    if (!G(t.bootstrap)) throw Error(\"Parcel \".concat(n, \" must have a valid bootstrap function\"));\n    if (!G(t.mount)) throw Error(\"Parcel \".concat(n, \" must have a valid mount function\"));\n    if (!G(t.unmount)) throw Error(\"Parcel \".concat(n, \" must have a valid unmount function\"));\n    if (t.update && !G(t.update)) throw Error(\"Parcel \".concat(n, \" provided an invalid update function\"));\n    var e = R(t.bootstrap),\n        r = R(t.mount),\n        a = R(t.unmount);\n    c.status = m, c.name = n, c.bootstrap = e, c.mount = r, c.unmount = a, c.timeouts = M(t.timeouts), t.update && (c.update = R(t.update), o.update = function (t) {\n      return c.customProps = t, z(function (t) {\n        return Promise.resolve().then(function () {\n          if (t.status !== g) throw Error(\"Cannot update parcel '\".concat(t.name, \"' because it is not mounted\"));\n          return t.status = w, L(t.update(X(t)), \"Updating parcel '\".concat(t.name, \"'\"), t.timeouts.mount).then(function () {\n            return t.status = g, t;\n          }).catch(function (n) {\n            var e = f(n, t);\n            throw t.status = E, e;\n          });\n        });\n      }(c));\n    });\n  })).then(function () {\n    return q(c, !0);\n  }),\n      y = v.then(function () {\n    return $(c, !0);\n  }),\n      b = new Promise(function (t, n) {\n    l = t, d = n;\n  });\n  return o = {\n    mount: function mount() {\n      return z(Promise.resolve().then(function () {\n        if (c.status !== h) throw Error(\"Cannot mount parcel '\".concat(name, \"' -- it is in a \").concat(c.status, \" status\"));\n        return e.parcels[i] = c, $(c);\n      }));\n    },\n    unmount: function unmount() {\n      return z(c.unmountThisParcel());\n    },\n    getStatus: function getStatus() {\n      return c.status;\n    },\n    loadPromise: z(s),\n    bootstrapPromise: z(v),\n    mountPromise: z(y),\n    unmountPromise: z(b)\n  };\n}\n\nfunction z(t) {\n  return t.then(function () {\n    return null;\n  });\n}\n\nfunction X(n) {\n  var e = i({}, n.customProps, {\n    name: n.name,\n    mountParcel: V.bind(n),\n    singleSpa: t\n  });\n  return n.unmountThisParcel && (e.unmountSelf = n.unmountThisParcel), e;\n}\n\nfunction Y(t) {\n  return Promise.resolve().then(function () {\n    return t.status !== l ? t : (t.status = p, Promise.resolve().then(function () {\n      var e = t.loadImpl(X(t));\n      if (!k(e)) throw Error(\"single-spa loading function did not return a promise. Check the second argument to registerApplication('\".concat(t.name, \"', loadingFunction, activityFunction)\"));\n      return e.then(function (e) {\n        var o;\n        return \"object\" !== r(n = e) && (o = \"does not export anything\"), G(n.bootstrap) || (o = \"does not export a bootstrap function or array of functions\"), G(n.mount) || (o = \"does not export a mount function or array of functions\"), G(n.unmount) || (o = \"does not export an unmount function or array of functions\"), o ? (u(o, t), t.status = E, t) : (n.devtools && n.devtools.overlays && (t.devtools.overlays = i({}, t.devtools.overlays, n.devtools.overlays)), t.status = m, t.bootstrap = R(n.bootstrap, \"App '\".concat(t.name, \"' bootstrap function\")), t.mount = R(n.mount, \"App '\".concat(t.name, \"' mount function\")), t.unmount = R(n.unmount, \"App '\".concat(t.name, \"' unmount function\")), t.unload = R(n.unload || [], \"App '\".concat(t.name, \"' unload function\")), t.timeouts = M(n.timeouts), t);\n      });\n    }).catch(function (n) {\n      return u(n, t), t.status = E, t;\n    }));\n    var n;\n  });\n}\n\nvar Z = {\n  hashchange: [],\n  popstate: []\n},\n    tt = [\"hashchange\", \"popstate\"];\n\nfunction nt(t) {\n  var n,\n      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n  if (\"string\" == typeof t) n = t;else if (this && this.href) n = this.href;else {\n    if (!(t && t.currentTarget && t.currentTarget.href && t.preventDefault)) throw Error(\"singleSpaNavigate must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag\");\n    n = t.currentTarget.href, t.preventDefault();\n  }\n  var r = st(window.location.href),\n      o = st(n);\n  if (0 === n.indexOf(\"#\")) window.location.hash = \"#\" + o.anchor;else if (r.host !== o.host && o.host) {\n    if (e.isTestingEnv) return {\n      wouldHaveReloadedThePage: !0\n    };\n    window.location.href = n;\n  } else !function (t, n) {\n    return n === t || n === \"/\" + t;\n  }(o.path, r.path) ? window.history.pushState(null, null, n) : window.location.hash = \"#\" + o.anchor;\n}\n\nfunction et(t) {\n  var n = this;\n\n  if (t) {\n    var e = t[0].type;\n    tt.indexOf(e) >= 0 && Z[e].forEach(function (e) {\n      e.apply(n, t);\n    });\n  }\n}\n\nfunction rt() {\n  Dt([], arguments);\n}\n\nwindow.addEventListener(\"hashchange\", rt), window.addEventListener(\"popstate\", rt);\nvar ot = window.addEventListener,\n    it = window.removeEventListener;\nwindow.addEventListener = function (t, n) {\n  if (!(\"function\" == typeof n && tt.indexOf(t) >= 0) || B(Z[t], function (t) {\n    return t === n;\n  })) return ot.apply(this, arguments);\n  Z[t].push(n);\n}, window.removeEventListener = function (t, n) {\n  if (!(\"function\" == typeof n && tt.indexOf(t) >= 0)) return it.apply(this, arguments);\n  Z[t] = Z[t].filter(function (t) {\n    return t !== n;\n  });\n};\nvar at = window.history.pushState;\n\nwindow.history.pushState = function (t) {\n  var n = at.apply(this, arguments);\n  return rt(ct(t)), n;\n};\n\nvar ut = window.history.replaceState;\n\nfunction ct(t) {\n  try {\n    return new PopStateEvent(\"popstate\", {\n      state: t\n    });\n  } catch (e) {\n    var n = document.createEvent(\"PopStateEvent\");\n    return n.initPopStateEvent(\"popstate\", !1, !1, t), n;\n  }\n}\n\nfunction st(t) {\n  for (var n = {\n    strictMode: !0,\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }, e = n.parser.strict.exec(t), r = {}, o = 14; o--;) {\n    r[n.key[o]] = e[o] || \"\";\n  }\n\n  return r[n.q.name] = {}, r[n.key[12]].replace(n.q.parser, function (t, e, o) {\n    e && (r[n.q.name][e] = o);\n  }), r;\n}\n\nwindow.history.replaceState = function (t) {\n  var n = ut.apply(this, arguments);\n  return rt(ct(t)), n;\n}, window.singleSpaNavigate = nt;\nvar ft = !1;\n\nfunction lt() {\n  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.jQuery;\n\n  if (t || window.$ && window.$.fn && window.$.fn.jquery && (t = window.$), t && !ft) {\n    var n = t.fn.on,\n        e = t.fn.off;\n    t.fn.on = function (t, e) {\n      return pt.call(this, n, window.addEventListener, t, e, arguments);\n    }, t.fn.off = function (t, n) {\n      return pt.call(this, e, window.removeEventListener, t, n, arguments);\n    }, ft = !0;\n  }\n}\n\nfunction pt(t, n, e, r, o) {\n  return \"string\" != typeof e ? t.apply(this, o) : (e.split(/\\s+/).forEach(function (t) {\n    tt.indexOf(t) >= 0 && (n(t, r), e = e.replace(t, \"\"));\n  }), \"\" === e.trim() ? this : t.apply(this, o));\n}\n\nvar mt = {};\n\nfunction dt(t) {\n  return Promise.resolve().then(function () {\n    var n = mt[t.name];\n    return n ? t.status === l ? (ht(t, n), t) : t.status === b ? n.promise.then(function () {\n      return t;\n    }) : t.status !== h ? t : (t.status = b, L(t.unload(X(t)), \"Unloading application '\".concat(t.name, \"'\"), t.timeouts.unload).then(function () {\n      return ht(t, n), t;\n    }).catch(function (e) {\n      return function (t, n, e) {\n        delete mt[t.name], delete t.bootstrap, delete t.mount, delete t.unmount, delete t.unload, u(e, t), t.status = E, n.reject(e);\n      }(t, n, e), t;\n    })) : t;\n  });\n}\n\nfunction ht(t, n) {\n  delete mt[t.name], delete t.bootstrap, delete t.mount, delete t.unmount, delete t.unload, t.status = l, n.resolve();\n}\n\nfunction vt(t, n, e, r) {\n  mt[t.name] = {\n    app: t,\n    resolve: e,\n    reject: r\n  }, Object.defineProperty(mt[t.name], \"promise\", {\n    get: n\n  });\n}\n\nvar gt = [];\n\nfunction wt() {\n  return gt.filter(P).map(x);\n}\n\nfunction yt() {\n  return gt.map(x);\n}\n\nfunction bt(t) {\n  var n = B(gt, function (n) {\n    return n.name === t;\n  });\n  return n ? n.status : null;\n}\n\nfunction Et(t, n, e) {\n  return console.warn('declareChildApplication is deprecated and will be removed in the next major version, use \"registerApplication\" instead'), Pt(t, n, e);\n}\n\nfunction Pt(t, n, e) {\n  var o,\n      i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};\n  if (\"string\" != typeof t || 0 === t.length) throw Error(\"The first argument must be a non-empty string 'appName'\");\n  if (-1 !== yt().indexOf(t)) throw Error(\"There is already an app declared with name \".concat(t));\n  if (\"object\" !== r(i) || Array.isArray(i)) throw Error(\"customProps must be an object\");\n  if (!n) throw Error(\"The application or loading function is required\");\n  if (o = \"function\" != typeof n ? function () {\n    return Promise.resolve(n);\n  } : n, \"function\" != typeof e) throw Error(\"The activeWhen argument must be a function\");\n  gt.push({\n    name: t,\n    loadImpl: o,\n    activeWhen: e,\n    status: l,\n    parcels: {},\n    devtools: {\n      overlays: {\n        options: {},\n        selectors: []\n      }\n    },\n    customProps: i\n  }), lt(), Dt();\n}\n\nfunction Ot(t) {\n  for (var n = [], e = 0; e < gt.length; e++) {\n    gt[e].activeWhen(t) && n.push(gt[e].name);\n  }\n\n  return n;\n}\n\nfunction Tt() {\n  return gt.filter(j).filter(A).filter(N);\n}\n\nfunction At(t, n) {\n  return console.warn('unloadChildApplication is deprecated and will be removed in the next major version, use \"unloadApplication\" instead'), Nt(t, n);\n}\n\nfunction Nt(t) {\n  var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n    waitForUnmount: !1\n  };\n  if (\"string\" != typeof t) throw Error(\"unloadApplication requires a string 'appName'\");\n  var e = B(gt, function (n) {\n    return n.name === t;\n  });\n  if (!e) throw Error(\"Could not unload application '\".concat(t, \"' because no such application has been registered\"));\n\n  var r,\n      o = function (t) {\n    return mt[t];\n  }(e.name);\n\n  if (n && n.waitForUnmount) {\n    if (o) return o.promise;\n    var i = new Promise(function (t, n) {\n      vt(e, function () {\n        return i;\n      }, t, n);\n    });\n    return i;\n  }\n\n  return o ? (r = o.promise, St(e, o.resolve, o.reject)) : r = new Promise(function (t, n) {\n    vt(e, function () {\n      return r;\n    }, t, n), St(e, t, n);\n  }), r;\n}\n\nfunction St(t, n, e) {\n  W(t).then(dt).then(function () {\n    n(), setTimeout(function () {\n      Dt();\n    });\n  }).catch(e);\n}\n\nvar jt = !1,\n    xt = [];\n\nfunction _t() {\n  return Dt();\n}\n\nfunction Dt() {\n  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],\n      n = arguments.length > 1 ? arguments[1] : void 0;\n  if (jt) return new Promise(function (t, e) {\n    xt.push({\n      resolve: t,\n      reject: e,\n      eventArguments: n\n    });\n  });\n  jt = !0;\n  var r = !0;\n  return Ut ? Promise.resolve().then(function () {\n    window.dispatchEvent(new e(\"single-spa:before-routing-event\", a()));\n    var n = Object.keys(mt).map(function (t) {\n      return mt[t].app;\n    }).filter(O).map(dt),\n        u = gt.filter(j).filter(P).filter(S).map(W).map(function (t) {\n      return t.then(dt);\n    }),\n        c = u.concat(n);\n    c.length > 0 && (r = !1);\n    var s = Promise.all(c),\n        f = Tt(),\n        l = f.map(function (t) {\n      return Y(t).then(q).then(function (t) {\n        return s.then(function () {\n          return $(t);\n        });\n      });\n    });\n    l.length > 0 && (r = !1);\n    var p = gt.filter(j).filter(O).filter(T).filter(N).filter(function (t) {\n      return f.indexOf(t) < 0;\n    }).map(function (t) {\n      return q(t).then(function () {\n        return s;\n      }).then(function () {\n        return $(t);\n      });\n    });\n    return p.length > 0 && (r = !1), s.catch(function (t) {\n      throw i(), t;\n    }).then(function () {\n      return i(), Promise.all(l.concat(p)).catch(function (n) {\n        throw t.forEach(function (t) {\n          return t.reject(n);\n        }), n;\n      }).then(function () {\n        return o(!1);\n      });\n    });\n  }) : Promise.resolve().then(function () {\n    var t = Tt().map(Y);\n    return t.length > 0 && (r = !1), Promise.all(t).then(o).catch(function (t) {\n      throw i(), t;\n    });\n  });\n\n  function o() {\n    var n = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],\n        o = wt();\n    n && i(), t.forEach(function (t) {\n      return t.resolve(o);\n    });\n\n    try {\n      var u = r ? \"single-spa:no-app-change\" : \"single-spa:app-change\";\n      window.dispatchEvent(new e(u, a())), window.dispatchEvent(new e(\"single-spa:routing-event\", a()));\n    } catch (t) {\n      setTimeout(function () {\n        throw t;\n      });\n    }\n\n    if (jt = !1, xt.length > 0) {\n      var c = xt;\n      xt = [], Dt(c);\n    }\n\n    return o;\n  }\n\n  function i() {\n    t.forEach(function (t) {\n      et(t.eventArguments);\n    }), et(n);\n  }\n\n  function a() {\n    var t = {\n      detail: {}\n    };\n    return n && n[0] && (t.detail.originalEvent = n[0]), t;\n  }\n}\n\nvar Ut = !1;\n\nfunction Ct() {\n  Ut = !0, Dt();\n}\n\nsetTimeout(function () {\n  Ut || console.warn(\"singleSpa.start() has not been called, \".concat(5e3, \"ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted. See https://github.com/CanopyTax/single-spa/blob/master/docs/single-spa-api.md#start\"));\n}, 5e3);\nvar It = {\n  getRawAppData: function getRawAppData() {\n    return [].concat(gt);\n  },\n  reroute: Dt,\n  NOT_LOADED: l,\n  toLoadPromise: Y,\n  toBootstrapPromise: q,\n  unregisterApplication: function unregisterApplication(t) {\n    if (!gt.find(function (n) {\n      return n.name === t;\n    })) throw Error(\"Cannot unregister application '\".concat(t, \"' because no such application has been registered\"));\n    return Nt(t).then(function () {\n      var n = gt.findIndex(function (n) {\n        return n.name === t;\n      });\n      gt.splice(n, 1);\n    });\n  }\n};\nwindow && window.__SINGLE_SPA_DEVTOOLS__ && (window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = It);\nexport { d as BOOTSTRAPPING, p as LOADING_SOURCE_CODE, g as MOUNTED, v as MOUNTING, m as NOT_BOOTSTRAPPED, l as NOT_LOADED, h as NOT_MOUNTED, E as SKIP_BECAUSE_BROKEN, y as UNMOUNTING, w as UPDATING, c as addErrorHandler, Ot as checkActivityFunctions, Et as declareChildApplication, lt as ensureJQuerySupport, yt as getAppNames, bt as getAppStatus, wt as getMountedApps, Q as mountRootParcel, nt as navigateToUrl, Pt as registerApplication, s as removeErrorHandler, D as setBootstrapMaxTime, U as setMountMaxTime, I as setUnloadMaxTime, C as setUnmountMaxTime, Ct as start, _t as triggerAppChange, Nt as unloadApplication, At as unloadChildApplication };","map":null,"metadata":{},"sourceType":"module"}